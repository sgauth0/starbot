// Starbot API - SQLite Schema
// Simple, local-first storage for projects, chats, and messages

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Project: top-level container for organizing chats
model Project {
  id         String   @id @default(uuid())
  name       String
  createdAt  DateTime @default(now())

  chats      Chat[]
  workspaces Workspace[]
  memories   MemoryDocument[]

  @@map("projects")
}

// Workspace: represents a code repository, folder, or cloud resource
model Workspace {
  id          String   @id @default(uuid())
  projectId   String
  type        String   // "repo" | "folder" | "cloud"
  identifier  String   // repo URL, folder path, or cloud resource ID
  createdAt   DateTime @default(now())

  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  chats       Chat[]
  memories    MemoryDocument[]

  @@index([projectId])
  @@map("workspaces")
}

// Chat: conversation thread within a project
model Chat {
  id          String   @id @default(uuid())
  projectId   String
  workspaceId String?
  title       String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project     Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  workspace   Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  messages    Message[]
  events      Event[]
  memories    MemoryDocument[]

  @@index([projectId])
  @@index([workspaceId])
  @@index([updatedAt])
  @@map("chats")
}

// Message: individual message in a chat
model Message {
  id         String   @id @default(uuid())
  chatId     String
  role       String   // user | assistant | tool | system
  content    String
  createdAt  DateTime @default(now())

  chat       Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@index([chatId])
  @@index([createdAt])
  @@map("messages")
}

// Event: audit trail for streaming events (optional, for debugging)
model Event {
  id         String   @id @default(uuid())
  chatId     String
  type       String   // token.delta | tool.start | tool.end | status | error
  payload    String   // JSON string
  createdAt  DateTime @default(now())

  chat       Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@index([chatId])
  @@index([type])
  @@index([createdAt])
  @@map("events")
}

// MemoryDocument: stores PMEMORY.md (project) or MEMORY.md (workspace)
model MemoryDocument {
  id          String   @id @default(uuid())
  scope       String   // "identity" | "chat" | "project" | "workspace"
  projectId   String?
  workspaceId String?
  chatId      String?
  content     String   // Markdown content
  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())

  project     Project?   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  workspace   Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  chat        Chat?      @relation(fields: [chatId], references: [id], onDelete: Cascade)
  chunks      MemoryChunk[]

  @@unique([scope, projectId, workspaceId])
  @@unique([scope, chatId])
  @@index([scope])
  @@index([projectId])
  @@index([workspaceId])
  @@index([chatId])
  @@map("memory_documents")
}

// MemoryChunk: chunked text from memory documents for embeddings (Phase 3)
model MemoryChunk {
  id              String   @id @default(uuid())
  memoryId        String
  text            String
  embeddingVector String?  // JSON-encoded float array (Phase 3)
  createdAt       DateTime @default(now())

  memory          MemoryDocument @relation(fields: [memoryId], references: [id], onDelete: Cascade)

  @@index([memoryId])
  @@map("memory_chunks")
}
